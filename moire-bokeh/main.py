import numpy as np

from bokeh.io import curdoc
from bokeh.layouts import row, column
from bokeh.models import ColumnDataSource, TextInput
from bokeh.plotting import figure
from bokeh.models import Range1d
from bokeh.models import HoverTool
from itertools import starmap

# FIXME: Imports like this are fragile in python 3 due to packages
#        taking precedence over local files.
from ui import float_eval
from ui import SliderTextInputPair
from ui import ShapeSelect

def main():
	zoom = 4
	index_radius = [30,30]

	hover = HoverTool(
		tooltips=[
			("layer", "@layer"),
			("index", "(@i, @j)"),
			("(x,y)", "($x, $y)"),
		],
	)

	# set up plot (styling in theme.yaml)
	plot = figure(toolbar_location=None, title='test', tools=[hover])
	source1 = ColumnDataSource(data=dict(x=[], y=[], i=[], j=[]))
	source2 = ColumnDataSource(data=dict(x=[], y=[], i=[], j=[]))
	plot.circle('x', 'y', source=source2, size=5, color='black')
	plot.circle('x', 'y', source=source1, size=10)

	controls = Controls()

	# filler values; this is only to ensure that they are instances of Range1d.
	plot.x_range = Range1d(0,1)
	plot.y_range = Range1d(0,1)

	# that does it.
	# I'm just going to write one big miserable mess of a function
	# so terrible that my OCPD will be incapable of "fixing" it
	def update():
		print('S', controls.scale(), 'R', controls.rotation(), 'T', controls.translation(),
		      'I', controls.center_i(), 'J', controls.center_j())
		direct_center = [controls.center_i(), controls.center_j()]
		if None in direct_center: # an invalid value was typed
			direct_center = [0., 0.]

		def rotation_matrix(theta):
			s,c = np.sin(theta), np.cos(theta)
			return np.array([[c,-s],[s,c]])
		def transform_cell(cell, rotation=0, scale=1):
			return np.array(cell).dot(rotation_matrix(rotation).transpose())*scale

		def cart_data(i, j, cell, shift):
			ijs = np.column_stack([i, j]) + shift
			xys = ijs.dot(cell)
			x,y = xys.transpose()
			return dict(x=x, y=y, i=i, j=j)

		from math import radians
		cell1 = controls.cell_1()
		cell2 = transform_cell(controls.cell_2(),
			rotation=radians(controls.rotation()),
			scale=(1 + controls.scale()),
		)

		# recenter plot
		# update range start and end in-place
		#  to work around this: https://github.com/bokeh/bokeh/issues/4014
		[cart_center] = np.array([direct_center]).dot(cell1)
		plot.x_range.start = cart_center[0] - 4.*zoom
		plot.x_range.end   = cart_center[0] + 4.*zoom
		plot.y_range.start = cart_center[1] - 4.*zoom
		plot.y_range.end   = cart_center[1] + 4.*zoom

		def nearest_index(cell, cart):
			direct = np.array([cart]).dot(np.linalg.inv(cell))
			# note: numpy floats do not round to ints like python floats do
			return [int(round(x)) for x in direct.flat]

		def direct_coords(cell, cart_center):
			index_center = nearest_index(cell, cart_center)
			assert all(isinstance(x, int) for x in index_center)
			def index_span(center, radius):
				return np.arange(center-radius, center+radius+1)
			I,J = starmap(index_span, zip(index_center, index_radius))
			i,j = [x.reshape(-1) for x in np.meshgrid(I, J)]
			return i,j

		i1,j1 = direct_coords(cell1, cart_center)
		i2,j2 = direct_coords(cell2, cart_center)
		source1.data = cart_data(i1, j1, cell1, [0,0])
		source1.data['layer'] = [1] * len(i1)
		source2.data = cart_data(i2, j2, cell2, [controls.translation(), 0])
		source2.data['layer'] = [2] * len(i1)

	def callback(i, dont, care):
		update()
	controls.set_callback(callback)

	update() # initialize

	# set up layout

	# add to document
	plot.sizing_mode='scale_both' # not sure if this even does anything
	root = row(children=[
		controls.model, plot,
	])
	curdoc().add_root(root)
	curdoc().title = "Moire"


class Controls:
	# NOTE:
	#  The actual public interface of this object is a bit hard to
	#  see because most of it is automatically generated. It is:
	# * self.model             : the bokeh model containing all widgets
	# * self.set_callback(cb)  : to be called once the callback is created
	# * self.scale(), self.rotation(), ...
	#          : automatically generated by the attr="..."
	#            arguments in __init__, for use in the callback.

	def __init__(self):

		# The helper functions automatically set up callbacks,
		#  and add attributes (e.g. self.scale)

		def slider_pair(attr, **kw):
			widget = SliderTextInputPair(**kw)
			setattr(self, attr, lambda: widget.value)
			# this lambda is because self._callback doesn't exist yet
			widget.add_callback(lambda a,b,c: self._callback(a,b,c))
			return widget.model

		def text_input(type, attr, **kw):
			widget = TextInput(**kw)
			def try_read(s):
				try: return type(widget.value)
				except ValueError: return None
			setattr(self, attr, lambda: try_read(widget.value))
			widget.on_change('value', lambda a,b,c: self._callback(a,b,c))
			return widget

		def select_shape(title, attr, **kw):
			widget = ShapeSelect(label=title, **kw)
			setattr(self, attr, lambda: widget.cell())
			widget.add_callback(lambda a,b,c: self._callback(a,b,c))
			return widget.model

		scale = slider_pair(
			title="Scale", attr='scale',
			type=float_eval, value=0.018,
			start=0.0, end=3.0, step=0.0001,
			)

		rotation = slider_pair(
			title="Rotation", attr='rotation',
			type=float_eval, value=10.8,
			start=0.0, end=60.0, step=0.0001,
			)

		translation = slider_pair(
			title="Translation", attr='translation',
			type=float_eval, value=0.5,
			start=0.0, end=0.5, step=0.0001,
			)

		center_i = text_input(
			title="Viewpoint Center I", attr='center_i',
			type=float_eval, value="0",
		)

		center_j = text_input(
			title="Viewpoint Center J", attr='center_j',
			type=float_eval, value="0",
		)

		shape_1 = select_shape(title='Layer 1', attr='cell_1')
		shape_2 = select_shape(title='Layer 2', attr='cell_2')

		self.model = \
			column(
				column(scale, rotation, translation),
				row(center_i, center_j),
				column(shape_1, shape_2),
			)

	# For setting the callback once it exists;
	# It is not possible to provide the callback on initialization
	#  because, ideally, the callback wants to be closed over an
	#  instance of this.
	# NOTE: This means there is a reference cycle between this class
	#       and the callback.  It may be possible to fix this using
	#       weakrefs, but it hardly matters right now since the
	#       Controls instance is never replaced.
	def set_callback(self, cb):
		self._callback = cb

main()
